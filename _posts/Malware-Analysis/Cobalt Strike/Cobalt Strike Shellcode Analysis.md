---
layout: post
title: "Cobalt Strike"
classes: wide
header:
ribbon: DodgerBlue
description: "Cobalt Strike Shellcode Analysis"
categories:
  #- Malware Analysis
toc: true
---



# Cobalt Strike Shellcode Analysis

## **Overview**

This report is my brief analysis for the **Cobalt Strike Shellcode**.

In the analysis, I cover **Cobalt Strike** shellcode functionalities and C2 extraction. 

## **IOCS**

The sample I used is a 64-bit Windows executable.  

**MD5**: e59655f2ee88853a7742142207c05dfa
**SHA256**: 3e1aadef9e05b98e31fc7994dd3405a45da77fbb69632e31f7aa95d397201de0

**Sample**: 
https://bazaar.abuse.ch/sample/3e1aadef9e05b98e31fc7994dd3405a45da77fbb69632e31f7aa95d397201de0/

## **Static analysis** 

During the initial static analysis using **Detect it Easy**, I looked at the entropy to see if there were any embedded files. In the case that there was an embedded file, it would see a red line at the eighth value on the diagram, and there would be also areas of high entropy, which typically indicate encrypted content. Since that is not the case here, I assume it is not an embedded payload (sample is not packed).

![[Pasted image 20240123110407.png]]

I looked at the import table and if I have quick look through that, we can see references to 
for example **CreateNamedPipeA**, **CreateThread** functions and if we scroll down a bit, we can see reference to **VirtualAlloc** and **VirtualProtect** functions. 

![[Pasted image 20240123113054.png]]
![[Pasted image 20240123145040.png]]

As many malware samples nowadays are packed, to confirm this sample is not, I used also **PEStudio** to see if there is a big difference in raw-size and virtual-size. 

![[Pasted image 20240123153916.png]]

Based on the **PEStudio**, there is no big difference between raw and virtual-size which is another indicator the our shellcode is not packed. 


## **Code Analysis** 

The malware uses KERNEL32.dll and msvcrt.dll for most imports.

The entry point of the malware contains outgoing references to two functions. 

![[Pasted image 20240206113855.png]]



In the function **FUN_00401990** malware acquire the current system date and time via **GetSystemTimeAsFileTime** in FILETIME format. 

![[Pasted image 20240206115157.png]]

Malware retrieves process ID (PID) using **GetCurrentProcessID** function.  
Malware retrieves the thread identifier of the calling thread using **GetCurrentThreadID** function. 


There are two references of **GetTickCount** function: 
FUN_004017f8 
FUN_00401990 - in the picture above 

![[Pasted image 20240212145614.png]]


In the function **FUN_004017f8** , the highlighted part stands for **Cobalt Strike Pipe String**, is it populated with random values **%c**. 
After the random values are added, the resulting string is written to **DAT_00408980**. 

![[Pasted image 20240211170136.png]]


By double clicking on **DAT_00408980**  in the decompiler window it will show us the location and  associated references.

![[Pasted image 20240211173006.png]]


In the first reference **FUN_00401630**, we can see that the **DAT_00408980** (which contains the resulting value from initial string), is used as the name of a named pipe via **CreateNamedPipe** API.  

![[Pasted image 20240211173255.png]]

So, the resulting value in the highlighted string is used to as the pipe name 
![[Pasted image 20240212110535.png]]
as it's contained in the first argument passed to **CreateNamedPipeA** function.

![[Pasted image 20240212120854.png]]

In this context, pipes are used to transfer shellcode contained within the malware sample. 

Malware used **ConnectNamedPipe** and **WriteFile** functions to write encrypted content into the named pipe.  

The second argument of the function **WriteFile** contains encrypted content.
![[Pasted image 20240212152544.png]]
![[Pasted image 20240212152826.png]]
![[Pasted image 20240212154456.png]]
![[Pasted image 20240212154816.png]]



Malware used **TLS callback** functions as **Anti-Debugging technique** to abuse to run a function before the entry point. 

![[Pasted image 20240212161204.png]]
![[Pasted image 20240212161352.png]]


Malware used **VirtualAlloc** function to allocate memory buffers for shellcode. 

Malware used **VirtualProtect** function to change the memory protection of the allocated memory to be executable in order to execute the shellcode.

Malware used **CreateThread** function to create a new thread (within the virtual address space of the calling process) that runs the shellcode. 

![[Pasted image 20240212170854.png]]

## Dynamic analysis 

During the dynamic analysis using x64dbg, I set a breakpoint on **VirtualAlloc** function via the following command ***bp VirtualAlloc***. So, we can monitor anything that the sample is writing to it.
Since we have breakpoint we can continue with running. 

![[Pasted image 20240124112103.png]]
![[Pasted image 20240124111742.png]]


We hit **VirtualAlloc** function which we mentioned in Static analysis. 
![[Pasted image 20240124112811.png]]

In case the process of running in x64dbg has broken on a TLS callback we can skip through that until we hit **VirtualAlloc** breakpoint which we set before. 



We can continue with execution till return. 
![[Pasted image 20240124114550.png]]


After executing **VirtualAlloc** function, its return value (stored in RAX), we can grab the address of memory buffer that it creates.  
![[Pasted image 20240124115039.png]]


I took that value and chose Follow in Dump (right click on value and select Follow in Dump). 
![[Pasted image 20240124154527.png]]


We can see new empty memory buffer that was created. 
![[Pasted image 20240124154741.png]]

To monitor this memory buffer I chose hardware breakpoint. I selected the first byte 0x00, right click and chose Breakpoint -> Hardware, Access -> Byte. 


I executed the sample again and we can see that Hardware Breakpoint has been triggered and 
0xFC byte has been written into the first spot. 0xFC byte in the first spot of memory buffer is very common for shellcode.    
![[Pasted image 20240124160237.png]]

I wanted to fill up this memory buffer so I chose execution till return. 

After executing, we can see that the memory buffer has filled up with junk text. 
![[Pasted image 20240124162211.png]]


Next, I right clicked on first byte 0xFC and chose Follow in Disassembler. 
It populated the Disassembly Window with the values from Memory Buffer Window (window containing dump data).      
![[Pasted image 20240124164457.png]]

So for example, we can see the first byte 0xFC in the Disassembly Window is cld instruction (string instruction), which is Clear Direction Flag.     

Next I removed the hardware breakpoint (right click on first byte 0xFC -> Breakpoint -> Remove Hardware), then I created another one but instead of  Breakpoint -> Hardware, Access -> Byte, 
I chose Breakpoint -> Hardware, Execute.
![[Pasted image 20240131171126.png]]


To find the address of that buffer in memory, I right clicked on the first byte 0xFC and chose Follow in Memory Map. 

![[Pasted image 20240201112244.png]]


To dump the memory to file I right clicked on the address and chose Dump Memory to File. 

![[Pasted image 20240201113530.png]]


In hex editor HxD, we can see a plain text string "wininet", which enables shellcode to interact with FTP and HTTP protocols to access Internet. 

![[Pasted image 20240201135622.png]]


Next we can see User Agent and even an IP address in plain text inside of the code but it is not always that case. IP address can be encoded or obfuscated.  

![[Pasted image 20240201135655.png]]
![[Pasted image 20240201135757.png]]



Another way how to emulate the execution of our shellcode is via Speakeasy (https://github.com/mandiant/speakeasy).  

![[Pasted image 20240202131439.png]]

-a means architecture, in our case it is 64-bit  
-r means raw as it is shellcode not a full PE file 
-t means target, path to our shellcode 

We can see reference to **LoadLibraryA**  function with "wininet" string, **InternetOpenA** function,  and also **InternetConnectA** function with IP address we saw in hex editor, User-Agent, reference to **VirtualAlloc** function.  So, we can determine from this emulation that the shellcode loads "wininet" library, calls out to C2 with particular User-Agent and then attempts allocate a buffer, read a file from the IP address and probably save it.    

In x64dbg I tried to determine the same information. For better view I chose graphical representation of shellcode by hitting G. 

Most of the time the point where the actual API calls are made is at the very end, usually in a call or jump instruction and very typically a jump to a register and not to a specific address as we can see in the picture below. 

![[Pasted image 20240202134432.png]]

I created a breakpoint on **jmp rax** instruction.  We can see **LoadLibrary** call to "wininet".  
![[Pasted image 20240202134934.png]]

I executed again and we can see **InternetOpenA** with "wininet"...
![[Pasted image 20240202140319.png]]

and  I executed again and we can see **InternetConnectA** with "wininet" and IP address as we saw within SpeakEasy emulation.      
![[Pasted image 20240202150522.png]]

Next execution showed us **HttpOpenRequestA** function call with partial URL.  
![[Pasted image 20240202150934.png]]

In the window where the parameters of the function have been pushed onto the stack we can see third parameter /QfDb of function **HttpOpenRequestA**.   
![[Pasted image 20240202151427.png]]

Based on the documentation https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-httpopenrequesta we can confirm that it is input third parameter **LPCSTR lpszObjectName**. 
![[Pasted image 20240202152223.png]]
![[Pasted image 20240202152636.png]]


Next execution showed us **HttpSendRequestA** function call with User-Agent. 
![[Pasted image 20240202171229.png]]

In the window where the parameters of the function have been pushed onto the stack we can see second parameter **User-Agent** of function **HttpSendRequestA**.   
![[Pasted image 20240202171311.png]]


Based on the documentation https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-httpsendrequesta we can confirm that it is input second parameter **LPCSTR lpszHeaders**. 
![[Pasted image 20240202172434.png]]
![[Pasted image 20240202174829.png]]

## **References** 

https://blog.nviso.eu/2021/04/26/anatomy-of-cobalt-strike-dll-stagers/?ref=embee-research.ghost.io

https://svch0st.medium.com/guide-to-named-pipes-and-hunting-for-cobalt-strike-pipes-dc46b2c5f575
