---
title: "Emotet"
classes: wide
ribbon: DodgerBlue
description: "Emotet Analysis"
categories:
  - Malware Analysis 
toc: true
---

# Emotet Analysis

## **Overview**

This report is my brief analysis for the **Emotet malware**.

In the analysis, I cover some **Emotet** malware functionalities. 


## **IOCS**

The sample I used is a 32-bit Windows executable.  

**MD5**: 6d86ca86e3829dbd7b4e6ddd4952dda5



**SHA256**:
7b1980602de122dab23f96c1b3b37ca852ca500f0af6969e2803815445a16e82

**Sample**: 
https://tria.ge/240524-nblllaeg6w


## **Analysis** 
## **Breakpoint on VirtualAllocEx and VirtualProtect API** 

The first step in monitoring virtual memory allocations was set a breakpoint on the return from the VirtualAllocEx API. The reason for placing the breakpoint at this return value is that once memory allocation has been completed and the API returns, the EAX register (or RAX in 64-bit systems), which holds the return value of the function, will contain the address of the newly allocated virtual memory.
![](/assets/images/malware-analysis/Emotet/Pasted image 20240822124857.png)


Here's an interesting thing: we are in kernel32.dll, and we've reached the VirtualAllocEx function. However, we noticed that there's no actual code there. Instead, there's just a jump instruction that leads to another jump, which ultimately jumps into another DLL.

![](/assets/images/malware-analysis/Emotet/Pasted image 20240822131923.png)


Why is not there any actual code for VirtualAllocEx and kernel32.dll. If we follow that jump, we will see that, the code leads to kernelbase.dll, where the VirtualAllocEx function resides.

![](/assets/images/malware-analysis/Emotet/Pasted image 20240822133844.png)
![](/assets/images/malware-analysis/Emotet/Pasted image 20240822134052.png)

In Windows 7, Microsoft has moved some core API's into kernelbase.dll and VirtualAllocEx is one of them. So even though you import kernel32.dll and use the VirtualAllocEx function there, its really just a redirect to kernelbase.dll and the reason why Microsoft has done this, is trying to make minimum set of API's that exists for Windows to run and it calls Min Win 
https://en.wikipedia.org/wiki/MinWin. So, if we are going to set up breakpoints on VirtualAllocEx, the code for it is actually not in kernel32.dll, it is in kernelbase.dll. 


I set a breakpoint at the return point of the VirtualAllocEx function.

![](/assets/images/malware-analysis/Emotet/Pasted image 20240827125454.png)
Based on the MSDN documentation https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex, the return value of the VirtualAllocEx function is base address of the allocated region of pages. This base address is where the newly allocated memory section starts.


The second breakpoint I was set at the entry point on VirtualProtect API. The first argument of the VirtualProtect API is the address of the memory region whose protection is being changed.

![](/assets/images/malware-analysis/Emotet/Pasted image 20240830184625.png)


## **Unpacking** 

I run until the breakpoint, we see that Emotet creates an allocation of memory at 0x001E0000.

![](/assets/images/malware-analysis/Emotet/Pasted image 20240828153313.png)


The API and DLL names taken from the code copied to 0x001E0000 are then de-obfuscated by Emotet.

*Deobfuscating VirtualAlloc*

![](/assets/images/malware-analysis/Emotet/Pasted image 20240828154600.png)


*Deobfuscating LoadLibraryExA and kernel32.dll*

![](/assets/images/malware-analysis/Emotet/Pasted image 20240828154301.png)


*Deobfuscated API names whose addresses are resolved*

![](/assets/images/malware-analysis/Emotet/Pasted image 20240830144713.png)

### **GetProcAddress call for invalid function name** 

Emotet attempts to call GetProcAddress with an invalid function name, "mknjht34tfserdgfwGetProcAddress". Since the name is invalid, the function returns a null value and the error code 0x0000007F (ERROR_PROC_NOT_FOUND).


*Call to GetProcAddress for an invalid API*

![](/assets/images/malware-analysis/Emotet/Pasted image 20240830164303.png)


*Call to GetProcAddress to fetch the address of GetProcAddress.*

![](/assets/images/malware-analysis/Emotet/Pasted image 20240830164349.png)


In x32dbg in Memory map tab I was looking for protected sections that are marked as Execute (ERW - Execute, Readable, Writeable). 

In the picture we can see our malware PE file and we can see that the text section that contains the executable code is marked as executable.    

![](/assets/images/malware-analysis/Emotet/Pasted image 20240902144948.png)

There is other section in memory marked as executable but not within our malware PE file. 
It is an allocated memory segment.  

![](/assets/images/malware-analysis/Emotet/Pasted image 20240902150005.png)

If we perform "Follow in Dump" on that memory segment, we can observe that a PE file has been injected directly into memory. This file does not correspond to any file on disk, meaning it wasn't loaded by the operating system in the usual way. Instead, it was injected into memory, where we can see the PE header, and the segment is marked as executable.

![](/assets/images/malware-analysis/Emotet/Pasted image 20240902151115.png)

![](/assets/images/malware-analysis/Emotet/Pasted image 20240902150133.png)


### **Emotet - Binary Dumped** 

I used the "Dump Memory to File" feature in x32dbg to save the contents of the memory segment to a file with the default name for further analysis.

![](/assets/images/malware-analysis/Emotet/Pasted image 20240902150418.png)


PEBear identifies that the PE file is memory dump and may require unmapping. 
![](/assets/images/malware-analysis/Emotet/Pasted image 20240902154459.png)

Another way to identify a mapped PE file is by examining the .text section, which typically contains the executable code. If you see that the .text section is filled with zeroes, it can indicate that the file has been mapped into memory.

There are two states a PE file can be in:

 **On-Disk Format:** This is the format in which the PE file exists as a file on disk. In this state, the headers and sections are aligned to raw offsets, meaning they correspond to the physical locations within the file itself.

**Mapped-in-Memory Format:** When the PE file is loaded into memory, it is mapped by the operating system, and the sections are relocated from their raw offsets to virtual addresses. This is the state in which the file is prepared to be executed.   

If we dump a PE file that is in its mapped state and examine the .text section in raw format, we might see zeroes. This typically happens because the raw pointer is referencing a memory location where the original section data no longer resides—it's just blank space. This suggests that the file is mapped in memory rather than being directly read from disk.

![](/assets/images/malware-analysis/Emotet/Pasted image 20240902155753.png)



## **Unmapping** 

There are a few different ways to unmap a file that's been dumped from mapped memory, such as using the tool 
https://github.com/hasherezade/pe_unmapper. 

To unmap file I opened dumped binary in PEBear tool. 

![](/assets/images/malware-analysis/Emotet/Pasted image 20240904115507.png)


The unmapping process is the following: 


**Adjust the Section Headers:**

1. Change the Raw Address to the **same** as Virtual Address
	![](/assets/images/malware-analysis/Emotet/Pasted image 20240904163155.png)


2. Raw Size must equal to the difference between start of next section minus end of the previous section, for example:  Raw address column: E000-1000 = D000 
	![](/assets/images/malware-analysis/Emotet/Pasted image 20240904172414.png)
	Because we are unmaping a PE file , we dont need relocation table. Relocation table (.reloc) only exists on disk, it is never written to memory. Disk and memory data must be the same. 
	Raw size of relocation table (.reloc) we set as zero.  


3. **Copy** the adjusted Raw Size to the Virtual Size
	![](/assets/images/malware-analysis/Emotet/Pasted image 20240904172208.png)


**Adjust the Optional Header Values**

4. Fix the Image Base Address in the Optional Header (the **same** as the **dump address**).
	![](/assets/images/malware-analysis/Emotet/Pasted image 20240904174528.png)



5. Calculate the SizeOfImage by adding the Virtual Address and Virtual Size of the last section.
	![](/assets/images/malware-analysis/Emotet/Pasted image 20240904180105.png)
	![](/assets/images/malware-analysis/Emotet/Pasted image 20240904180231.png)


	In our case it is: .reloc section: 13000+0 = 13000
	![](/assets/images/malware-analysis/Emotet/Pasted image 20240904181719.png)



## **References** 
https://medium.com/@dryan5346/emotet-malware-analysis-25a31d325731
